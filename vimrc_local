""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ColorScheme
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set t_8b=[48;2;%lu;%lu;%lum
set t_8f=[38;2;%lu;%lu;%lum
if (has("termguicolors"))
  set termguicolors
endif
set background=dark
try
  colorscheme one
  " highlight Pmenu ctermbg=gray guibg=gray
catch
endtry


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Lightline config
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set noshowmode

let g:lightline = {
      \ 'colorscheme': 'one',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'gitbranch', 'readonly', 'relativepath', 'modified' ] ]
      \ },
      \ 'component_function': {
      \   'gitbranch': 'fugitive#head'
      \ },
      \ }



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ALE
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:ale_enabled = 1

let g:ale_linters = {
      \ 'cs': ['OmniSharp'],
      \}

let g:ale_fixers = {
      \ 'elixir': ['mix_format'],
      \}
let g:ale_fix_on_save = 1

" ale specific mappings
nmap <leader>a :ALENextWrap <cr>
nmap <leader>e :ALEDetail <cr>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Elm
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:elm_format_autosave = 1
let g:elm_setup_keybindings = 0
let g:elm_jump_to_error = 1
let g:elm_detailed_complete = 1
let g:elm_make_show_warnings = 1

au FileType elm nmap <leader>f :ElmFormat<cr>
" au FileType elm nmap <leader>e <Plug>(elm-error-detail)
au FileType elm nmap <leader>d <Plug>(elm-show-docs)
" au FileType elm nmap <leader>m <Plug>(elm-make-main)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Clojure
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
au FileType clojure RainbowParenthesesActivate
au FileType clojure RainbowParenthesesLoadRound
au FileType clojure RainbowParenthesesLoadSquare
au FileType clojure RainbowParenthesesLoadBraces

" Clojure mapping
nmap <leader>ca :%Eval <cr>

" OmniSharp
"


let g:OmniSharp_timeout = 5
let g:OmniSharp_server_path = '/mnt/c/workspace/omnisharp/OmniSharp.exe'
let g:OmniSharp_translate_cygwin_wsl = 1
let g:OmniSharp_selector_ui = 'fzf'    " Use fzf.vim
let g:OmniSharp_highlight_types = 3
let g:OmniSharp_server_stdio = 1
let g:coc_global_extensions= [ 'coc-omnisharp' ]

set completeopt=longest,menuone,preview

set previewheight=5

augroup omnisharp_commands
  autocmd!
      " Show type information automatically when the cursor stops moving
      autocmd CursorHold *.cs call OmniSharp#TypeLookupWithoutDocumentation()

       " The following commands are contextual, based on the cursor position.
       autocmd FileType cs nnoremap <buffer> gd :OmniSharpGotoDefinition<CR>
       autocmd FileType cs nnoremap <buffer> <Leader>fi :OmniSharpFindImplementations<CR>
       autocmd FileType cs nnoremap <buffer> <Leader>fs :OmniSharpFindSymbol<CR>
       autocmd FileType cs nnoremap <buffer> <Leader>fu :OmniSharpFindUsages<CR>

       " Finds members in the current buffer
       autocmd FileType cs nnoremap <buffer> <Leader>fm :OmniSharpFindMembers<CR>

       autocmd FileType cs nnoremap <buffer> <Leader>fx :OmniSharpFixUsings<CR>
       autocmd FileType cs nnoremap <buffer> <Leader>tt :OmniSharpTypeLookup<CR>
       autocmd FileType cs nnoremap <buffer> <Leader>dc :OmniSharpDocumentation<CR>
       autocmd FileType cs nnoremap <buffer> <C-\> :OmniSharpSignatureHelp<CR>
       autocmd FileType cs inoremap <buffer> <C-\> <C-o>:OmniSharpSignatureHelp<CR>

       " Navigate up and down by method/property/fields
       autocmd FileType cs nnoremap <buffer> <C-k> :OmniSharpNavigateUp<CR>
       autocmd FileType cs nnoremap <buffer> <C-j> :OmniSharpNavigateDown<CR>

       " Find all code errors/warnings for the current solution and populate
       " the quicfix window
       autocmd FileType cs nnoremap <buffer> <Leader>cc :OmniSharpGlobalCodeCheck<CR>
augroup END

" Contextual code actions (uses fzf, CtrlP or unite.vim when available)
nnoremap <Leader><Space> :OmniSharpGetCodeActions<CR>
" Run code actions with text selected in visual mode to extract method
xnoremap <Leader><Space> :call OmniSharp#GetCodeActions('visual')<CR>

" Rename with dialog
nnoremap <Leader>nm :OmniSharpRename<CR>
nnoremap <F2> :OmniSharpRename<CR>
" Rename without dialog - with cursor on the symbol to rename: `:Rename
" newname`
command! -nargs=1 Rename :call OmniSharp#RenameTo("<args>")

nnoremap <Leader>cf :OmniSharpCodeFormat<CR>
" Start the omnisharp server for the current solution
nnoremap <Leader>ss :OmniSharpStartServer<CR>
nnoremap <Leader>sp :OmniSharpStopServer<CR>

" COC
"

 " Better display for messages
 set cmdheight=2

 " You will have bad experience for diagnostic messages when it's default " 4000.
 set updatetime=300

 " don't give |ins-completion-menu| messages.
 set shortmess+=c
 " always showsigncolumns
 set signcolumn=yes

 " Use tab for trigger completion with characters ahead and navigate.
 inoremap <silent><expr> <TAB>
       \ pumvisible() ? "\<C-n>" :
       \ <SID>check_back_space() ? "\<TAB>" :
       \ coc#refresh()
 inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

 function! s:check_back_space() abort
     let col = col('.') - 1
     return !col || getline('.')[col - 1]  =~# '\s'
 endfunction

 " Use <c-space> to trigger completion.
 inoremap <silent><expr> <c-space> coc#refresh()

 " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
 " position.
 " " Coc only does snippet and additional edit on confirm.
 inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

 ": Use K to show documentation in preview window
 nnoremap <silent> K :call <SID>show_documentation()<CR>


 function! s:show_documentation()
   if (index(['vim','help'], &filetype) >= 0)
     execute 'h '.expand('<cword>')
   else
     call CocAction('doHover')
   endif
 endfunction

